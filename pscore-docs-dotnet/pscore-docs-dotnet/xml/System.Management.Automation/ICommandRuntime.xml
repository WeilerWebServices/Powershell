<Type Name="ICommandRuntime" FullName="System.Management.Automation.ICommandRuntime">
  <TypeSignature Language="C#" Value="public interface ICommandRuntime" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ICommandRuntime" />
  <TypeSignature Language="DocId" Value="T:System.Management.Automation.ICommandRuntime" />
  <TypeSignature Language="VB.NET" Value="Public Interface ICommandRuntime" />
  <TypeSignature Language="F#" Value="type ICommandRuntime = interface" />
  <AssemblyInfo>
    <AssemblyName>System.Management.Automation</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>
             This interface defines the set of functionality that must be implemented to directly
             execute an instance of a Cmdlet.
             </summary>
    <remarks>
             When a cmdlet is instantiated and run directly, all calls to the stream APIs will be proxied
             through to an instance of this class. For example, when a cmdlet calls WriteObject, the
             WriteObject implementation on the instance of the class implementing this interface will be
             called. The Monad implementation provides a default implementation of this class for use with
             standalone cmdlets as well as the implementation provided for running in the monad engine itself.
            
             If you do want to run Cmdlet instances standalone and capture their output with more
             fidelity than is provided for with the default implementation, then you should create your own
             implementation of this class and pass it to cmdlets before calling the Cmdlet Invoke() or
             Execute() methods.
             </remarks>
  </Docs>
  <Members>
    <Member MemberName="CurrentPSTransaction">
      <MemberSignature Language="C#" Value="public System.Management.Automation.PSTransactionContext CurrentPSTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Management.Automation.PSTransactionContext CurrentPSTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.ICommandRuntime.CurrentPSTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentPSTransaction As PSTransactionContext" />
      <MemberSignature Language="F#" Value="member this.CurrentPSTransaction : System.Management.Automation.PSTransactionContext" Usage="System.Management.Automation.ICommandRuntime.CurrentPSTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.PSTransactionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets an object that surfaces the current PowerShell transaction.
            When this object is disposed, PowerShell resets the active transaction
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public System.Management.Automation.Host.PSHost Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Management.Automation.Host.PSHost Host" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.ICommandRuntime.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As PSHost" />
      <MemberSignature Language="F#" Value="member this.Host : System.Management.Automation.Host.PSHost" Usage="System.Management.Automation.ICommandRuntime.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.PSHost</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns an instance of the PSHost implementation for this environment.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldContinue">
      <MemberSignature Language="C#" Value="public bool ShouldContinue (string query, string caption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldContinue(string query, string caption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldContinue (query As String, caption As String) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member ShouldContinue : string * string -&gt; bool" Usage="iCommandRuntime.ShouldContinue (query, caption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="caption" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="query">
             Textual query of whether the action should be performed,
             usually in the form of a question.
             </param>
        <param name="caption">
             Caption of the window which may be displayed
             when the user is prompted whether or not to perform the action.
             It may be displayed by some hosts, but not all.
             </param>
        <summary>
             Called by a cmdlet to confirm an operation or grouping of operations with the user.
             This differs from ShouldProcess in that it is not affected by
             preference settings or command-line parameters,
             it always does the query.
             This variant only offers Yes/No, not YesToAll/NoToAll.
             </summary>
        <returns>
             If ShouldContinue returns true, the operation should be performed.
             If ShouldContinue returns false, the operation should not be
             performed, and the Cmdlet should move on to the next target resource.
             </returns>
        <remarks>
             Cmdlets using ShouldContinue should also offer a "bool Force"
             parameter which bypasses the calls to ShouldContinue
             and ShouldProcess.
             If this is not done, it will be difficult to use the Cmdlet
             from scripts and non-interactive hosts.
            
             Cmdlets using ShouldContinue must still verify operations
             which will make changes using ShouldProcess.
             This will assure that settings such as -WhatIf work properly.
             You may call ShouldContinue either before or after ShouldProcess.
            
             ShouldContinue may only be called during a call to this Cmdlet's
             implementation of ProcessRecord, BeginProcessing or EndProcessing,
             and only from that thread.
            
             Cmdlets may have different "classes" of confirmations.  For example,
             "del" confirms whether files in a particular directory should be
             deleted, whether read-only files should be deleted, etc.
             Cmdlets can use ShouldContinue to store YesToAll/NoToAll members
             for each such "class" to keep track of whether the user has
             confirmed "delete all read-only files" etc.
             ShouldProcess offers YesToAll/NoToAll automatically,
             but answering YesToAll or NoToAll applies to all subsequent calls
             to ShouldProcess for the Cmdlet instance.
            
             An implementation should prompt the user in an appropriate manner
             and return true or false. An alternative trivial implementation
             would be to just return true all the time.
             </remarks>
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String,System.Boolean@,System.Boolean@)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldContinue">
      <MemberSignature Language="C#" Value="public bool ShouldContinue (string query, string caption, ref bool yesToAll, ref bool noToAll);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldContinue(string query, string caption, bool&amp; yesToAll, bool&amp; noToAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String,System.Boolean@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldContinue (query As String, caption As String, ByRef yesToAll As Boolean, ByRef noToAll As Boolean) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member ShouldContinue : string * string *  *  -&gt; bool" Usage="iCommandRuntime.ShouldContinue (query, caption, yesToAll, noToAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="caption" Type="System.String" />
        <Parameter Name="yesToAll" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="noToAll" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="query">
             Textual query of whether the action should be performed,
             usually in the form of a question.
             </param>
        <param name="caption">
             Caption of the window which may be displayed
             when the user is prompted whether or not to perform the action.
             It may be displayed by some hosts, but not all.
             </param>
        <param name="yesToAll">
             true iff user selects YesToAll.  If this is already true,
             ShouldContinue will bypass the prompt and return true.
             </param>
        <param name="noToAll">
             true iff user selects NoToAll.  If this is already true,
             ShouldContinue will bypass the prompt and return false.
             </param>
        <summary>
             Called to confirm an operation or grouping of operations with the user.
             This differs from ShouldProcess in that it is not affected by
             preference settings or command-line parameters,
             it always does the query.
             This variant offers Yes, No, YesToAll and NoToAll.
             </summary>
        <returns>
             If ShouldContinue returns true, the operation should be performed.
             If ShouldContinue returns false, the operation should not be
             performed, and the Cmdlet should move on to the next target resource.
             </returns>
        <remarks>
             Cmdlets using ShouldContinue should also offer a "bool Force"
             parameter which bypasses the calls to ShouldContinue
             and ShouldProcess.
             If this is not done, it will be difficult to use the Cmdlet
             from scripts and non-interactive hosts.
            
             Cmdlets using ShouldContinue must still verify operations
             which will make changes using ShouldProcess.
             This will assure that settings such as -WhatIf work properly.
             You may call ShouldContinue either before or after ShouldProcess.
            
             ShouldContinue may only be called during a call to this Cmdlet's
             implementation of ProcessRecord, BeginProcessing or EndProcessing,
             and only from that thread.
            
             Cmdlets may have different "classes" of confirmations.  For example,
             "del" confirms whether files in a particular directory should be
             deleted, whether read-only files should be deleted, etc.
             Cmdlets can use ShouldContinue to store YesToAll/NoToAll members
             for each such "class" to keep track of whether the user has
             confirmed "delete all read-only files" etc.
             ShouldProcess offers YesToAll/NoToAll automatically,
             but answering YesToAll or NoToAll applies to all subsequent calls
             to ShouldProcess for the Cmdlet instance.
            
             An implementation should prompt the user in an appropriate manner
             and return true or false. An alternative trivial implementation
             would be to just return true all the time.
             </remarks>
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldProcess">
      <MemberSignature Language="C#" Value="public bool ShouldProcess (string target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldProcess(string target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldProcess (target As String) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member ShouldProcess : string -&gt; bool" Usage="iCommandRuntime.ShouldProcess target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
             Name of the target resource being acted upon. This will
             potentially be displayed to the user.
             </param>
        <summary>
             Called by the cmdlet to confirm the operation with the user.  Cmdlets which make changes
             (e.g. delete files, stop services etc.) should call ShouldProcess
             to give the user the opportunity to confirm that the operation
             should actually be performed.
             </summary>
        <returns>
             If ShouldProcess returns true, the operation should be performed.
             If ShouldProcess returns false, the operation should not be
             performed, and the Cmdlet should move on to the next target resource.
            
             An implementation should prompt the user in an appropriate manner
             and return true or false. An alternative trivial implementation
             would be to just return true all the time.
             </returns>
        <remarks>
             A Cmdlet should declare
             [Cmdlet( SupportsShouldProcess = true )]
             if-and-only-if it calls ShouldProcess before making changes.
            
             ShouldProcess may only be called during a call to this Cmdlet's
             implementation of ProcessRecord, BeginProcessing or EndProcessing,
             and only from that thread.
            
             ShouldProcess will take into account command-line settings
             and preference variables in determining what it should return
             and whether it should prompt the user.
             </remarks>
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String,System.String,System.Management.Automation.ShouldProcessReason@)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String,System.Boolean@,System.Boolean@)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldProcess">
      <MemberSignature Language="C#" Value="public bool ShouldProcess (string target, string action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldProcess(string target, string action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldProcess (target As String, action As String) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member ShouldProcess : string * string -&gt; bool" Usage="iCommandRuntime.ShouldProcess (target, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="action" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
             Name of the target resource being acted upon. This will
             potentially be displayed to the user.
             </param>
        <param name="action">
             Name of the action which is being performed. This will
             potentially be displayed to the user. (default is Cmdlet name)
             </param>
        <summary>
             Called by a cmdlet to confirm the operation with the user.  Cmdlets which make changes
             (e.g. delete files, stop services etc.) should call ShouldProcess
             to give the user the opportunity to confirm that the operation
             should actually be performed.
            
             This variant allows the caller to specify text for both the
             target resource and the action.
             </summary>
        <returns>
             If ShouldProcess returns true, the operation should be performed.
             If ShouldProcess returns false, the operation should not be
             performed, and the Cmdlet should move on to the next target resource.
            
             An implementation should prompt the user in an appropriate manner
             and return true or false. An alternative trivial implementation
             would be to just return true all the time.
             </returns>
        <remarks>
             A Cmdlet should declare
             [Cmdlet( SupportsShouldProcess = true )]
             if-and-only-if it calls ShouldProcess before making changes.
            
             ShouldProcess may only be called during a call to this Cmdlet's
             implementation of ProcessRecord, BeginProcessing or EndProcessing,
             and only from that thread.
            
             ShouldProcess will take into account command-line settings
             and preference variables in determining what it should return
             and whether it should prompt the user.
             </remarks>
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String,System.String,System.Management.Automation.ShouldProcessReason@)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String,System.Boolean@,System.Boolean@)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldProcess">
      <MemberSignature Language="C#" Value="public bool ShouldProcess (string verboseDescription, string verboseWarning, string caption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldProcess(string verboseDescription, string verboseWarning, string caption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldProcess (verboseDescription As String, verboseWarning As String, caption As String) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member ShouldProcess : string * string * string -&gt; bool" Usage="iCommandRuntime.ShouldProcess (verboseDescription, verboseWarning, caption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verboseDescription" Type="System.String" />
        <Parameter Name="verboseWarning" Type="System.String" />
        <Parameter Name="caption" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="verboseDescription">
             Textual description of the action to be performed.
             This is what will be displayed to the user for
             ActionPreference.Continue.
             </param>
        <param name="verboseWarning">
             Textual query of whether the action should be performed,
             usually in the form of a question.
             This is what will be displayed to the user for
             ActionPreference.Inquire.
             </param>
        <param name="caption">
             Caption of the window which may be displayed
             if the user is prompted whether or not to perform the action.
             <paramref name="caption" /> may be displayed by some hosts, but not all.
             </param>
        <summary>
             Called by a cmdlet to confirm the operation with the user.  Cmdlets which make changes
             (e.g. delete files, stop services etc.) should call ShouldProcess
             to give the user the opportunity to confirm that the operation
             should actually be performed.
            
             This variant allows the caller to specify the complete text
             describing the operation, rather than just the name and action.
             </summary>
        <returns>
             If ShouldProcess returns true, the operation should be performed.
             If ShouldProcess returns false, the operation should not be
             performed, and the Cmdlet should move on to the next target resource.
             </returns>
        <remarks>
             A Cmdlet should declare
             [Cmdlet( SupportsShouldProcess = true )]
             if-and-only-if it calls ShouldProcess before making changes.
            
             ShouldProcess may only be called during a call to this Cmdlet's
             implementation of ProcessRecord, BeginProcessing or EndProcessing,
             and only from that thread.
            
             ShouldProcess will take into account command-line settings
             and preference variables in determining what it should return
             and whether it should prompt the user.
            
             An implementation should prompt the user in an appropriate manner
             and return true or false. An alternative trivial implementation
             would be to just return true all the time.
             </remarks>
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String,System.String,System.Management.Automation.ShouldProcessReason@)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String,System.Boolean@,System.Boolean@)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldProcess">
      <MemberSignature Language="C#" Value="public bool ShouldProcess (string verboseDescription, string verboseWarning, string caption, out System.Management.Automation.ShouldProcessReason shouldProcessReason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldProcess(string verboseDescription, string verboseWarning, string caption, [out] valuetype System.Management.Automation.ShouldProcessReason&amp; shouldProcessReason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String,System.String,System.Management.Automation.ShouldProcessReason@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldProcess (verboseDescription As String, verboseWarning As String, caption As String, ByRef shouldProcessReason As ShouldProcessReason) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member ShouldProcess : string * string * string *  -&gt; bool" Usage="iCommandRuntime.ShouldProcess (verboseDescription, verboseWarning, caption, shouldProcessReason)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verboseDescription" Type="System.String" />
        <Parameter Name="verboseWarning" Type="System.String" />
        <Parameter Name="caption" Type="System.String" />
        <Parameter Name="shouldProcessReason" Type="System.Management.Automation.ShouldProcessReason&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="verboseDescription">
             Textual description of the action to be performed.
             This is what will be displayed to the user for
             ActionPreference.Continue.
             </param>
        <param name="verboseWarning">
             Textual query of whether the action should be performed,
             usually in the form of a question.
             This is what will be displayed to the user for
             ActionPreference.Inquire.
             </param>
        <param name="caption">
             Caption of the window which may be displayed
             if the user is prompted whether or not to perform the action.
             <paramref name="caption" /> may be displayed by some hosts, but not all.
             </param>
        <param name="shouldProcessReason">
             Indicates the reason(s) why ShouldProcess returned what it returned.
             Only the reasons enumerated in
             <see cref="T:System.Management.Automation.ShouldProcessReason" />
             are returned.
             </param>
        <summary>
             Called by a cmdlet to confirm the operation with the user.  Cmdlets which make changes
             (e.g. delete files, stop services etc.) should call ShouldProcess
             to give the user the opportunity to confirm that the operation
             should actually be performed.
            
             This variant allows the caller to specify the complete text
             describing the operation, rather than just the name and action.
             </summary>
        <returns>
             If ShouldProcess returns true, the operation should be performed.
             If ShouldProcess returns false, the operation should not be
             performed, and the Cmdlet should move on to the next target resource.
             </returns>
        <remarks>
             A Cmdlet should declare
             [Cmdlet( SupportsShouldProcess = true )]
             if-and-only-if it calls ShouldProcess before making changes.
            
             ShouldProcess may only be called during a call to this Cmdlet's
             implementation of ProcessRecord, BeginProcessing or EndProcessing,
             and only from that thread.
            
             ShouldProcess will take into account command-line settings
             and preference variables in determining what it should return
             and whether it should prompt the user.
            
             An implementation should prompt the user in an appropriate manner
             and return true or false. An alternative trivial implementation
             would be to just return true all the time.
             </remarks>
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldProcess(System.String,System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.ShouldContinue(System.String,System.String,System.Boolean@,System.Boolean@)" />
      </Docs>
    </Member>
    <Member MemberName="ThrowTerminatingError">
      <MemberSignature Language="C#" Value="public void ThrowTerminatingError (System.Management.Automation.ErrorRecord errorRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ThrowTerminatingError(class System.Management.Automation.ErrorRecord errorRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.ThrowTerminatingError(System.Management.Automation.ErrorRecord)" />
      <MemberSignature Language="F#" Value="abstract member ThrowTerminatingError : System.Management.Automation.ErrorRecord -&gt; unit" Usage="iCommandRuntime.ThrowTerminatingError errorRecord" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorRecord" Type="System.Management.Automation.ErrorRecord" />
      </Parameters>
      <Docs>
        <param name="errorRecord">
             The error which caused the command to be terminated
             </param>
        <summary>
             This interface will be called to route fatal errors from a cmdlet.
             </summary>
        <remarks>
          <see cref="M:System.Management.Automation.Cmdlet.ThrowTerminatingError(System.Management.Automation.ErrorRecord)" />
             terminates the command, where
             <see cref="M:System.Management.Automation.ICommandRuntime.WriteError(System.Management.Automation.ErrorRecord)" />
             allows the command to continue.
            
             The cmdlet can also terminate the command by simply throwing
             any exception.  When the cmdlet's implementation of
             <see cref="M:System.Management.Automation.Cmdlet.ProcessRecord" />,
             <see cref="M:System.Management.Automation.Cmdlet.BeginProcessing" /> or
             <see cref="M:System.Management.Automation.Cmdlet.EndProcessing" />
             throws an exception, the Engine will always catch the exception
             and report it as a terminating error.
             However, it is preferred for the cmdlet to call
             <see cref="M:System.Management.Automation.Cmdlet.ThrowTerminatingError(System.Management.Automation.ErrorRecord)" />,
             so that the additional information in
             <see cref="T:System.Management.Automation.ErrorRecord" />
             is available.
            
             It is up to the implementation of this routine to determine what
             if any information is to be added. It should encapsulate the
             error record into an exception and then throw that exception.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAvailable">
      <MemberSignature Language="C#" Value="public bool TransactionAvailable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TransactionAvailable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.TransactionAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Function TransactionAvailable () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TransactionAvailable : unit -&gt; bool" Usage="iCommandRuntime.TransactionAvailable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns true if a transaction is available and active.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteCommandDetail">
      <MemberSignature Language="C#" Value="public void WriteCommandDetail (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteCommandDetail(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.WriteCommandDetail(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteCommandDetail (text As String)" />
      <MemberSignature Language="F#" Value="abstract member WriteCommandDetail : string -&gt; unit" Usage="iCommandRuntime.WriteCommandDetail text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">text to be written to log</param>
        <summary>
             Write text into pipeline execution log.
             </summary>
        <remarks>
             Use WriteCommandDetail to write important information about cmdlet execution to
             pipeline execution log.
            
             If LogPipelineExecutionDetail is turned on, this information will be written
             to monad log under log category "Pipeline execution detail"
             </remarks>
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteDebug(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteVerbose(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteProgress(System.Management.Automation.ProgressRecord)" />
      </Docs>
    </Member>
    <Member MemberName="WriteDebug">
      <MemberSignature Language="C#" Value="public void WriteDebug (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteDebug(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.WriteDebug(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteDebug (text As String)" />
      <MemberSignature Language="F#" Value="abstract member WriteDebug : string -&gt; unit" Usage="iCommandRuntime.WriteDebug text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">debug output</param>
        <summary>
            Display debug information
            </summary>
        <remarks>
            This API is called by the cmdlet to display debug information on the inner workings
            of the Cmdlet. An implementation of this interface should display this information in
            an appropriately distinctive manner (e.g. through a different color or in a separate
            status window. In simple implementations, just ignoring the text and returning is sufficient.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteError">
      <MemberSignature Language="C#" Value="public void WriteError (System.Management.Automation.ErrorRecord errorRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteError(class System.Management.Automation.ErrorRecord errorRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.WriteError(System.Management.Automation.ErrorRecord)" />
      <MemberSignature Language="F#" Value="abstract member WriteError : System.Management.Automation.ErrorRecord -&gt; unit" Usage="iCommandRuntime.WriteError errorRecord" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorRecord" Type="System.Management.Automation.ErrorRecord" />
      </Parameters>
      <Docs>
        <param name="errorRecord">error</param>
        <summary>
            Internal variant: Writes the specified error to the error pipe.
            </summary>
        <remarks>
            Do not call WriteError(e.ErrorRecord).
            The ErrorRecord contained in the ErrorRecord property of
            an exception which implements IContainsErrorRecord
            should not be passed directly to WriteError, since it contains
            a <see cref="T:System.Management.Automation.ParentContainsErrorRecordException" />
            rather than the real exception.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteObject">
      <MemberSignature Language="C#" Value="public void WriteObject (object sendToPipeline);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteObject(object sendToPipeline) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.WriteObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteObject (sendToPipeline As Object)" />
      <MemberSignature Language="F#" Value="abstract member WriteObject : obj -&gt; unit" Usage="iCommandRuntime.WriteObject sendToPipeline" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sendToPipeline" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sendToPipeline">
            The object that needs to be written.  This will be written as
            a single object, even if it is an enumeration.
            </param>
        <summary>
            Called to write objects to the output pipe.
            </summary>
        <remarks>
            When the cmdlet wants to write a single object out, it will call this
            API. It is up to the implementation to decide what to do with these objects.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteObject">
      <MemberSignature Language="C#" Value="public void WriteObject (object sendToPipeline, bool enumerateCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteObject(object sendToPipeline, bool enumerateCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.WriteObject(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteObject (sendToPipeline As Object, enumerateCollection As Boolean)" />
      <MemberSignature Language="F#" Value="abstract member WriteObject : obj * bool -&gt; unit" Usage="iCommandRuntime.WriteObject (sendToPipeline, enumerateCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sendToPipeline" Type="System.Object" />
        <Parameter Name="enumerateCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sendToPipeline">
            The object that needs to be written to the pipeline.
            </param>
        <param name="enumerateCollection">
            true if the collection should be enumerated
            </param>
        <summary>
            Called to write one or more objects to the output pipe.
            If the object is a collection and the enumerateCollection flag
            is true, the objects in the collection
            will be written individually.
            </summary>
        <remarks>
             When the cmdlet wants to write multiple objects out, it will call this
            API. It is up to the implementation to decide what to do with these objects.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteProgress">
      <MemberSignature Language="C#" Value="public void WriteProgress (System.Management.Automation.ProgressRecord progressRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteProgress(class System.Management.Automation.ProgressRecord progressRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.WriteProgress(System.Management.Automation.ProgressRecord)" />
      <MemberSignature Language="F#" Value="abstract member WriteProgress : System.Management.Automation.ProgressRecord -&gt; unit" Usage="iCommandRuntime.WriteProgress progressRecord" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progressRecord" Type="System.Management.Automation.ProgressRecord" />
      </Parameters>
      <Docs>
        <param name="progressRecord">progress information</param>
        <summary>
             Called by the cmdlet to display progress information
             </summary>
        <remarks>
             Use WriteProgress to display progress information about
             the activity of your Task, when the operation of your Task
             could potentially take a long time.
            
             By default, progress output will
             be displayed, although this can be configured with the
             ProgressPreference shell variable.
            
             The implementation of the API should display these progress records
             in a fashion appropriate for the application. For example, a GUI application
             would implement this as a progress bar of some sort.
             </remarks>
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteDebug(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteWarning(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteVerbose(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="WriteProgress">
      <MemberSignature Language="C#" Value="public void WriteProgress (long sourceId, System.Management.Automation.ProgressRecord progressRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteProgress(int64 sourceId, class System.Management.Automation.ProgressRecord progressRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.WriteProgress(System.Int64,System.Management.Automation.ProgressRecord)" />
      <MemberSignature Language="F#" Value="abstract member WriteProgress : int64 * System.Management.Automation.ProgressRecord -&gt; unit" Usage="iCommandRuntime.WriteProgress (sourceId, progressRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceId" Type="System.Int64" />
        <Parameter Name="progressRecord" Type="System.Management.Automation.ProgressRecord" />
      </Parameters>
      <Docs>
        <param name="sourceId">
            Identifies which command is reporting progress
            </param>
        <param name="progressRecord">
            Progress status to be displayed
            </param>
        <summary>
            Displays progress output if enabled
            </summary>
        <remarks>
            The implementation of the API should display these progress records
            in a fashion appropriate for the application. For example, a GUI application
            would implement this as a progress bar of some sort.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteVerbose">
      <MemberSignature Language="C#" Value="public void WriteVerbose (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteVerbose(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.WriteVerbose(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteVerbose (text As String)" />
      <MemberSignature Language="F#" Value="abstract member WriteVerbose : string -&gt; unit" Usage="iCommandRuntime.WriteVerbose text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">verbose output</param>
        <summary>
             Called when the cmdlet want to display verbose information
             </summary>
        <remarks>
             Cmdlets use WriteVerbose to display more detailed information about
             the activity of the Cmdlet.  By default, verbose output will
             not be displayed, although this can be configured with the
             VerbosePreference shell variable
             or the -Verbose and -Debug command-line options.
            
             The implementation of this API should display this addition information
             in an appropriate manner e.g. in a different color in a console application
             or in a separate window in a GUI application.
             </remarks>
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteDebug(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteWarning(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteProgress(System.Management.Automation.ProgressRecord)" />
      </Docs>
    </Member>
    <Member MemberName="WriteWarning">
      <MemberSignature Language="C#" Value="public void WriteWarning (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteWarning(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.ICommandRuntime.WriteWarning(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteWarning (text As String)" />
      <MemberSignature Language="F#" Value="abstract member WriteWarning : string -&gt; unit" Usage="iCommandRuntime.WriteWarning text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">warning output</param>
        <summary>
             Called by the cmdlet to display warning information
             </summary>
        <remarks>
             Use WriteWarning to display warnings about
             the activity of your Cmdlet.  By default, warning output will
             be displayed, although this can be configured with the
             WarningPreference shell variable
             or the -Verbose and -Debug command-line options.
            
             The implementation of this API should display this addition information
             in an appropriate manner e.g. in a different color in a console application
             or in a separate window in a GUI application.
             </remarks>
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteDebug(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteVerbose(System.String)" />
        <altmember cref="M:System.Management.Automation.ICommandRuntime.WriteProgress(System.Management.Automation.ProgressRecord)" />
      </Docs>
    </Member>
  </Members>
</Type>