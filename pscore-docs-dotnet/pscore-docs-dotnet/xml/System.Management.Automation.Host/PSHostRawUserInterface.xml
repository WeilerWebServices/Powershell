<Type Name="PSHostRawUserInterface" FullName="System.Management.Automation.Host.PSHostRawUserInterface">
  <TypeSignature Language="C#" Value="public abstract class PSHostRawUserInterface" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PSHostRawUserInterface extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Management.Automation.Host.PSHostRawUserInterface" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PSHostRawUserInterface" />
  <TypeSignature Language="F#" Value="type PSHostRawUserInterface = class" />
  <AssemblyInfo>
    <AssemblyName>System.Management.Automation</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            
             Defines the lowest-level user interface functions that an interactive application hosting an MSH
             <see cref="T:System.Management.Automation.Runspaces.Runspace" /> can choose to implement if it wants to
             support any cmdlet that does character-mode interaction with the user.
            
             </summary>
    <remarks>
            
             It models an 2-dimensional grid of cells called a Buffer.  A buffer has a visible rectangular region, called a window.
             Each cell of the grid has a character, a foreground color, and a background color.  When the buffer has input focus, it
             shows a cursor positioned in one cell.  Keystrokes can be read from the buffer and optionally echoed at the current
             cursor position.
            
             </remarks>
    <altmember cref="T:System.Management.Automation.Host.PSHost" />
    <altmember cref="T:System.Management.Automation.Host.PSHostUserInterface" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PSHostRawUserInterface ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
            
             Protected constructor which does nothing.  Provided per .Net design guidelines section 4.3.1
            
             </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public abstract ConsoleColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ConsoleColor BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.Host.PSHostRawUserInterface.BackgroundColor" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property BackgroundColor As ConsoleColor" />
      <MemberSignature Language="F#" Value="member this.BackgroundColor : ConsoleColor with get, set" Usage="System.Management.Automation.Host.PSHostRawUserInterface.BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            
             Gets or sets the color used to render the background behind characters on the screen buffer.  Each character cell in
             the screen buffer can have a separate background color.
            
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.ForegroundColor" />
      </Docs>
    </Member>
    <Member MemberName="BufferSize">
      <MemberSignature Language="C#" Value="public abstract System.Management.Automation.Host.Size BufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.Host.Size BufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.Host.PSHostRawUserInterface.BufferSize" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property BufferSize As Size" />
      <MemberSignature Language="F#" Value="member this.BufferSize : System.Management.Automation.Host.Size with get, set" Usage="System.Management.Automation.Host.PSHostRawUserInterface.BufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            
             Gets or sets the current size of the screen buffer, measured in character cells.
            
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxPhysicalWindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.CursorPosition" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxWindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowPosition" />
      </Docs>
    </Member>
    <Member MemberName="CursorPosition">
      <MemberSignature Language="C#" Value="public abstract System.Management.Automation.Host.Coordinates CursorPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.Host.Coordinates CursorPosition" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.Host.PSHostRawUserInterface.CursorPosition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property CursorPosition As Coordinates" />
      <MemberSignature Language="F#" Value="member this.CursorPosition : System.Management.Automation.Host.Coordinates with get, set" Usage="System.Management.Automation.Host.PSHostRawUserInterface.CursorPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.Coordinates</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            
             Gets or sets the cursor position in the screen buffer.  The view window always adjusts it's location over the screen
             buffer such that the cursor is always visible.
            
             </summary>
        <value>To be added.</value>
        <remarks>
            
             To write to the screen buffer without updating the cursor position, use
             <see cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" /> or
             <see cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" /></remarks>
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxPhysicalWindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowPosition" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxWindowSize" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />
      </Docs>
    </Member>
    <Member MemberName="CursorSize">
      <MemberSignature Language="C#" Value="public abstract int CursorSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CursorSize" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.Host.PSHostRawUserInterface.CursorSize" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property CursorSize As Integer" />
      <MemberSignature Language="F#" Value="member this.CursorSize : int with get, set" Usage="System.Management.Automation.Host.PSHostRawUserInterface.CursorSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            
             Gets or sets the cursor size as a percentage 0..100.
            
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.CursorPosition" />
      </Docs>
    </Member>
    <Member MemberName="FlushInputBuffer">
      <MemberSignature Language="C#" Value="public abstract void FlushInputBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FlushInputBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.FlushInputBuffer" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FlushInputBuffer ()" />
      <MemberSignature Language="F#" Value="abstract member FlushInputBuffer : unit -&gt; unit" Usage="pSHostRawUserInterface.FlushInputBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            
             Resets the keyboard input buffer.
            
             </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ReadKey" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ReadKey(System.Management.Automation.Host.ReadKeyOptions)" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.KeyAvailable" />
      </Docs>
    </Member>
    <Member MemberName="ForegroundColor">
      <MemberSignature Language="C#" Value="public abstract ConsoleColor ForegroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ConsoleColor ForegroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.Host.PSHostRawUserInterface.ForegroundColor" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ForegroundColor As ConsoleColor" />
      <MemberSignature Language="F#" Value="member this.ForegroundColor : ConsoleColor with get, set" Usage="System.Management.Automation.Host.PSHostRawUserInterface.ForegroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            
             Gets or sets the color used to render characters on the screen buffer. Each character cell in the screen buffer can
             have a separate foreground color.
            
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <!--Design note: we separate Foreground and Background colors into separate properties rather than having a single
             property that is a ColorAttribute.  While a single property that takes a struct is consistent with all of our
             other properties that take structs (e.g. -Position, -Size), I anticipate that the more common use-case for color
             is to just change the foreground color.-->
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.BackgroundColor" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferContents">
      <MemberSignature Language="C#" Value="public abstract System.Management.Automation.Host.BufferCell[,] GetBufferContents (System.Management.Automation.Host.Rectangle rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Management.Automation.Host.BufferCell[,] GetBufferContents(valuetype System.Management.Automation.Host.Rectangle rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.GetBufferContents(System.Management.Automation.Host.Rectangle)" />
      <MemberSignature Language="F#" Value="abstract member GetBufferContents : System.Management.Automation.Host.Rectangle -&gt; System.Management.Automation.Host.BufferCell[,]" Usage="pSHostRawUserInterface.GetBufferContents rectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.BufferCell[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rectangle" Type="System.Management.Automation.Host.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rectangle">
            
             The rectangle on the screen buffer to extract.
            
             </param>
        <summary>
            
             Extracts a rectangular region of the screen buffer.
            
             </summary>
        <returns>
            
             An array of <see cref="T:System.Management.Automation.Host.BufferCell" /> objects extracted from
             the rectangular region of the screen buffer specified by <paramref name="rectangle" /></returns>
        <remarks>
            
             If the rectangle is completely outside of the screen buffer, a BufferCell array of zero rows and column will be
             returned.
            
             If the rectangle is partially outside of the screen buffer, the area where the screen buffer and rectangle overlap
             will be read and returned. The size of the returned array is the same as that of r. Each BufferCell in the
             non-overlapping area of this array is set as follows:
            
             Character is the space (' ')
             ForegroundColor to the current foreground color, given by the ForegroundColor property of this class.
             BackgroundColor to the current background color, given by the BackgroundColor property of this class.
            
             The resulting array is organized in row-major order for performance reasons.  The screen buffer, however, is
             organized in column-major order -- e.g. you specify the column index first, then the row index second, as in (x, y).
             This means that a cell at screen buffer position (x, y) is in the array element [y, x].
            
             </remarks>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Int32,System.Int32,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Management.Automation.Host.Size,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.String[],System.ConsoleColor,System.ConsoleColor)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.Char)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ScrollBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
      </Docs>
    </Member>
    <Member MemberName="KeyAvailable">
      <MemberSignature Language="C#" Value="public abstract bool KeyAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeyAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.Host.PSHostRawUserInterface.KeyAvailable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property KeyAvailable As Boolean" />
      <MemberSignature Language="F#" Value="member this.KeyAvailable : bool" Usage="System.Management.Automation.Host.PSHostRawUserInterface.KeyAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            
             A non-blocking call to examine if a keystroke is waiting in the input buffer.
            
             </summary>
        <value>
            
             True if a keystroke is waiting in the input buffer, false if not.
            
             </value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ReadKey" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ReadKey(System.Management.Automation.Host.ReadKeyOptions)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.FlushInputBuffer" />
      </Docs>
    </Member>
    <Member MemberName="LengthInBufferCells">
      <MemberSignature Language="C#" Value="public virtual int LengthInBufferCells (char source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LengthInBufferCells(char source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LengthInBufferCells (source As Char) As Integer" />
      <MemberSignature Language="F#" Value="abstract member LengthInBufferCells : char -&gt; int&#xA;override this.LengthInBufferCells : char -&gt; int" Usage="pSHostRawUserInterface.LengthInBufferCells source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="source">
            
             The character whose length we want to know.
            
             </param>
        <summary>
            
             Determines the number of BufferCells a character occupies.
            
             </summary>
        <returns>
            
             The default implementation returns 1.
            
             </returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Int32,System.Int32,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Management.Automation.Host.Size,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.String[],System.ConsoleColor,System.ConsoleColor)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.Char)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.GetBufferContents(System.Management.Automation.Host.Rectangle)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ScrollBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
      </Docs>
    </Member>
    <Member MemberName="LengthInBufferCells">
      <MemberSignature Language="C#" Value="public virtual int LengthInBufferCells (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LengthInBufferCells(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LengthInBufferCells (source As String) As Integer" />
      <MemberSignature Language="F#" Value="abstract member LengthInBufferCells : string -&gt; int&#xA;override this.LengthInBufferCells : string -&gt; int" Usage="pSHostRawUserInterface.LengthInBufferCells source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">
            
             The string whose length we want to know.
            
             </param>
        <summary>
            
             Determines the number of BufferCells a string occupies.
            
             </summary>
        <returns>
            
             The default implementation returns the length of <paramref name="source" /></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Int32,System.Int32,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Management.Automation.Host.Size,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.String[],System.ConsoleColor,System.ConsoleColor)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.Char)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String,System.Int32)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.GetBufferContents(System.Management.Automation.Host.Rectangle)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ScrollBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
      </Docs>
    </Member>
    <Member MemberName="LengthInBufferCells">
      <MemberSignature Language="C#" Value="public virtual int LengthInBufferCells (string source, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LengthInBufferCells(string source, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LengthInBufferCells (source As String, offset As Integer) As Integer" />
      <MemberSignature Language="F#" Value="abstract member LengthInBufferCells : string * int -&gt; int&#xA;override this.LengthInBufferCells : string * int -&gt; int" Usage="pSHostRawUserInterface.LengthInBufferCells (source, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
            
             The string whose substring length we want to know.
            
             </param>
        <param name="offset">
            
             Offset where the substring begins in <paramref name="source" /></param>
        <summary>
            
             Determines the number of BufferCells a substring of a string occupies.
            
             </summary>
        <returns>
            
             The default implementation calls <see cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String)" /> method
             with the substring extracted from the <paramref name="source" /> string
             starting at the offset <paramref name="offset" /></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Int32,System.Int32,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Management.Automation.Host.Size,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.String[],System.ConsoleColor,System.ConsoleColor)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.Char)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.GetBufferContents(System.Management.Automation.Host.Rectangle)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ScrollBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
      </Docs>
    </Member>
    <Member MemberName="MaxPhysicalWindowSize">
      <MemberSignature Language="C#" Value="public abstract System.Management.Automation.Host.Size MaxPhysicalWindowSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.Host.Size MaxPhysicalWindowSize" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxPhysicalWindowSize" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MaxPhysicalWindowSize As Size" />
      <MemberSignature Language="F#" Value="member this.MaxPhysicalWindowSize : System.Management.Automation.Host.Size" Usage="System.Management.Automation.Host.PSHostRawUserInterface.MaxPhysicalWindowSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            
             Gets the largest window possible for the current font and display hardware, ignoring the current buffer dimensions.  In
             other words, the dimensions of the largest window that could be rendered in the current display, if the buffer was
             at least as large.
            
             </summary>
        <value>To be added.</value>
        <remarks>
            
             To resize the window to this dimension, use <see cref="P:System.Management.Automation.Host.PSHostRawUserInterface.BufferSize" />
             to first check and, if necessary, adjust, the screen buffer size.
            
             </remarks>
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxWindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.BufferSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.CursorPosition" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowPosition" />
      </Docs>
    </Member>
    <Member MemberName="MaxWindowSize">
      <MemberSignature Language="C#" Value="public abstract System.Management.Automation.Host.Size MaxWindowSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.Host.Size MaxWindowSize" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxWindowSize" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MaxWindowSize As Size" />
      <MemberSignature Language="F#" Value="member this.MaxWindowSize : System.Management.Automation.Host.Size" Usage="System.Management.Automation.Host.PSHostRawUserInterface.MaxWindowSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            
             Gets the size of the largest window possible for the current buffer, current font, and current display hardware.
             The view window cannot be larger than the screen buffer or the current display (the display the window is rendered on).
            
             </summary>
        <value>
            
             The largest dimensions the window can be resized to without resizing the screen buffer.
            
             </value>
        <remarks>
            
             Always returns a value less than or equal to
             <see cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxPhysicalWindowSize" />.
            
             </remarks>
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxPhysicalWindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.BufferSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.CursorPosition" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowPosition" />
      </Docs>
    </Member>
    <Member MemberName="NewBufferCellArray">
      <MemberSignature Language="C#" Value="public System.Management.Automation.Host.BufferCell[,] NewBufferCellArray (System.Management.Automation.Host.Size size, System.Management.Automation.Host.BufferCell contents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Management.Automation.Host.BufferCell[,] NewBufferCellArray(valuetype System.Management.Automation.Host.Size size, valuetype System.Management.Automation.Host.BufferCell contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Management.Automation.Host.Size,System.Management.Automation.Host.BufferCell)" />
      <MemberSignature Language="F#" Value="member this.NewBufferCellArray : System.Management.Automation.Host.Size * System.Management.Automation.Host.BufferCell -&gt; System.Management.Automation.Host.BufferCell[,]" Usage="pSHostRawUserInterface.NewBufferCellArray (size, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.BufferCell[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Management.Automation.Host.Size" />
        <Parameter Name="contents" Type="System.Management.Automation.Host.BufferCell" />
      </Parameters>
      <Docs>
        <param name="size">
            
             The width and height of the resulting array.
            
             </param>
        <param name="contents">
            
             The cell to be copied to each of the elements of the resulting array.
            
             </param>
        <summary>
            
             Same as <see cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Int32,System.Int32,System.Management.Automation.Host.BufferCell)" /></summary>
        <returns>
            
             An array of BufferCells whose size is <paramref name="size" /> and where each cell's value is
             based on <paramref name="contents" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
            
             If <paramref name="size" />.Width or <paramref name="size" />.Height is less than 1.
            
             </exception>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Int32,System.Int32,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.String[],System.ConsoleColor,System.ConsoleColor)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.Char)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.GetBufferContents(System.Management.Automation.Host.Rectangle)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ScrollBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
      </Docs>
    </Member>
    <Member MemberName="NewBufferCellArray">
      <MemberSignature Language="C#" Value="public System.Management.Automation.Host.BufferCell[,] NewBufferCellArray (int width, int height, System.Management.Automation.Host.BufferCell contents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Management.Automation.Host.BufferCell[,] NewBufferCellArray(int32 width, int32 height, valuetype System.Management.Automation.Host.BufferCell contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Int32,System.Int32,System.Management.Automation.Host.BufferCell)" />
      <MemberSignature Language="VB.NET" Value="Public Function NewBufferCellArray (width As Integer, height As Integer, contents As BufferCell) As BufferCell(,)" />
      <MemberSignature Language="F#" Value="member this.NewBufferCellArray : int * int * System.Management.Automation.Host.BufferCell -&gt; System.Management.Automation.Host.BufferCell[,]" Usage="pSHostRawUserInterface.NewBufferCellArray (width, height, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.BufferCell[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="contents" Type="System.Management.Automation.Host.BufferCell" />
      </Parameters>
      <Docs>
        <param name="width">
            
             The number of columns of the resulting array
            
             </param>
        <param name="height">
            
             The number of rows of the resulting array
            
             </param>
        <param name="contents">
            
             The cell to be copied to each of the elements of the resulting array.
            
             </param>
        <summary>
            
             Creates a 2D array of BufferCells by examining <paramref name="contents" />.Character.
            
             <seealso cref="T:System.Management.Automation.Host.PSHostRawUserInterface" /></summary>
        <returns>
            
             A <paramref name="width" /> by <paramref name="height" /> array of BufferCells where each cell's value is
             based on <paramref name="contents" /><paramref name="backgroundColor" /></returns>
        <remarks>
            
             If the character takes one BufferCell to display as determined by LengthInBufferCells,
             one BufferCell is allocated with its Character set to the character and BufferCellType to
             BufferCell.Complete.
             On the other hand, if it takes two BufferCells, two adjacent BufferCells on a row
             in the returned array will be allocated: the first has Character
             set to the character and BufferCellType to BufferCellType.Leading and the second Character
             set to (char)0 and BufferCellType to BufferCellType.Trailing. Moreover, if <paramref name="width" />
             is odd, the last column will just contain the leading cell.
             <paramref name="prototype" />.BufferCellType is not used in creating the array.
             The resulting array is suitable for use with the PSHostRawUserInterface.SetBufferContents method.
            
             </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="width" /> is less than 1;
             <paramref name="height" /> is less than 1.
            
             </exception>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Management.Automation.Host.Size,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.String[],System.ConsoleColor,System.ConsoleColor)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.Char)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.GetBufferContents(System.Management.Automation.Host.Rectangle)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ScrollBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
      </Docs>
    </Member>
    <Member MemberName="NewBufferCellArray">
      <MemberSignature Language="C#" Value="public System.Management.Automation.Host.BufferCell[,] NewBufferCellArray (string[] contents, ConsoleColor foregroundColor, ConsoleColor backgroundColor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Management.Automation.Host.BufferCell[,] NewBufferCellArray(string[] contents, valuetype System.ConsoleColor foregroundColor, valuetype System.ConsoleColor backgroundColor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.String[],System.ConsoleColor,System.ConsoleColor)" />
      <MemberSignature Language="VB.NET" Value="Public Function NewBufferCellArray (contents As String(), foregroundColor As ConsoleColor, backgroundColor As ConsoleColor) As BufferCell(,)" />
      <MemberSignature Language="F#" Value="member this.NewBufferCellArray : string[] * ConsoleColor * ConsoleColor -&gt; System.Management.Automation.Host.BufferCell[,]" Usage="pSHostRawUserInterface.NewBufferCellArray (contents, foregroundColor, backgroundColor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.BufferCell[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contents" Type="System.String[]" />
        <Parameter Name="foregroundColor" Type="System.ConsoleColor" />
        <Parameter Name="backgroundColor" Type="System.ConsoleColor" />
      </Parameters>
      <Docs>
        <param name="contents">
            
             String array based on which the two dimensional array of BufferCells will be created.
            
             </param>
        <param name="foregroundColor">
            
             Foreground color of the buffer cells in the resulting array.
            
             </param>
        <param name="backgroundColor">
            
             Background color of the buffer cells in the resulting array.
            
             </param>
        <summary>
            
             Creates a two dimensional array of BufferCells by examining each character in <paramref name="contents" />.
            
             </summary>
        <returns>
            
             A two dimensional array of BufferCells whose characters are the same as those in <paramref name="contents" />
             and whose foreground and background colors set to <paramref name="foregroundColor" /> and
             <paramref name="backgroundColor" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="contents" /> is null;
             Any string in <paramref name="contents" /> is null or empty
            
             </exception>
        <remark>
            
             If a character C takes one BufferCell to display as determined by LengthInBufferCells,
             one BufferCell is allocated with its Character set to C and BufferCellType to BufferCell.Complete.
             On the other hand, if C takes two BufferCell, two adjacent BufferCells on a row in
             the returned array will be allocated: the first has Character set to C and BufferCellType to
             <see cref="F:System.Management.Automation.Host.BufferCellType.Leading" /> and the second
             Character set to (char)0 and Type to
             <see cref="F:System.Management.Automation.Host.BufferCellType.Trailing" />. Hence, the returned
             BufferCell array has <paramref name="contents" />.Length number of rows and number of columns
             equal to the largest number of cells a string in <paramref name="contents" /> takes. The
             foreground and background colors of the cells are initialized to
             <paramref name="foregroundColor" /> and <paramref name="backgroundColor" />, respectively.
             The resulting array is suitable for use with <see cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
             and <see cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />.
            
             </remark>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Int32,System.Int32,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Management.Automation.Host.Size,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.Char)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.GetBufferContents(System.Management.Automation.Host.Rectangle)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ScrollBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public System.Management.Automation.Host.KeyInfo ReadKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Management.Automation.Host.KeyInfo ReadKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.ReadKey" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadKey () As KeyInfo" />
      <MemberSignature Language="F#" Value="member this.ReadKey : unit -&gt; System.Management.Automation.Host.KeyInfo" Usage="pSHostRawUserInterface.ReadKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.KeyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            
             Reads a key stroke from the keyboard device, blocking until a keystroke is typed.
             Same as ReadKey(ReadKeyOptions.IncludeKeyDown)
            
             </summary>
        <returns>
            
             Key stroke when a key is pressed.
            
             </returns>
        <remarks>To be added.</remarks>
        <example>
          <MSH>
                     $Host.UI.RawUI.ReadKey()
                 </MSH>
        </example>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ReadKey(System.Management.Automation.Host.ReadKeyOptions)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.FlushInputBuffer" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.KeyAvailable" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowPosition" />
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public abstract System.Management.Automation.Host.KeyInfo ReadKey (System.Management.Automation.Host.ReadKeyOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Management.Automation.Host.KeyInfo ReadKey(valuetype System.Management.Automation.Host.ReadKeyOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.ReadKey(System.Management.Automation.Host.ReadKeyOptions)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadKey (options As ReadKeyOptions) As KeyInfo" />
      <MemberSignature Language="F#" Value="abstract member ReadKey : System.Management.Automation.Host.ReadKeyOptions -&gt; System.Management.Automation.Host.KeyInfo" Usage="pSHostRawUserInterface.ReadKey options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.KeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Management.Automation.Host.ReadKeyOptions" />
      </Parameters>
      <Docs>
        <param name="options">
            
             A bit mask of the options to be used to read the keyboard. Constants defined by
             <see cref="T:System.Management.Automation.Host.ReadKeyOptions" /></param>
        <summary>
            
             Reads a key stroke from the keyboard device, blocking until a keystroke is typed.
             Either one of ReadKeyOptions.IncludeKeyDown and ReadKeyOptions.IncludeKeyUp or both must be specified.
            
             </summary>
        <returns>
            
             Key stroke depending on the value of <paramref name="options" />.
            
             </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
            
             Neither ReadKeyOptions.IncludeKeyDown nor ReadKeyOptions.IncludeKeyUp is specified.
            
             </exception>
        <example>
          <MSH>
                     $option = [System.Management.Automation.Host.ReadKeyOptions]"IncludeKeyDown";
                     $host.UI.RawUI.ReadKey($option)
                 </MSH>
        </example>
        <altmember cref="T:System.Management.Automation.Host.ReadKeyOptions" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ReadKey" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ReadKey(System.Management.Automation.Host.ReadKeyOptions)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.FlushInputBuffer" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.KeyAvailable" />
      </Docs>
    </Member>
    <Member MemberName="ScrollBufferContents">
      <MemberSignature Language="C#" Value="public abstract void ScrollBufferContents (System.Management.Automation.Host.Rectangle source, System.Management.Automation.Host.Coordinates destination, System.Management.Automation.Host.Rectangle clip, System.Management.Automation.Host.BufferCell fill);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollBufferContents(valuetype System.Management.Automation.Host.Rectangle source, valuetype System.Management.Automation.Host.Coordinates destination, valuetype System.Management.Automation.Host.Rectangle clip, valuetype System.Management.Automation.Host.BufferCell fill) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.ScrollBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ScrollBufferContents (source As Rectangle, destination As Coordinates, clip As Rectangle, fill As BufferCell)" />
      <MemberSignature Language="F#" Value="abstract member ScrollBufferContents : System.Management.Automation.Host.Rectangle * System.Management.Automation.Host.Coordinates * System.Management.Automation.Host.Rectangle * System.Management.Automation.Host.BufferCell -&gt; unit" Usage="pSHostRawUserInterface.ScrollBufferContents (source, destination, clip, fill)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Management.Automation.Host.Rectangle" />
        <Parameter Name="destination" Type="System.Management.Automation.Host.Coordinates" />
        <Parameter Name="clip" Type="System.Management.Automation.Host.Rectangle" />
        <Parameter Name="fill" Type="System.Management.Automation.Host.BufferCell" />
      </Parameters>
      <Docs>
        <param name="source">
            
             Indicates the region of the screen to be scrolled.
            
             </param>
        <param name="destination">
            
             Indicates the upper left coordinates of the region of the screen to receive the source region contents.  The target
             region is the same size as the source region.
            
             </param>
        <param name="clip">
            
             Indicates the region of the screen to include in the operation.  If a cell would be changed by the operation but
             does not fall within the clip region, it will be unchanged.
            
             </param>
        <param name="fill">
            
             The character and attributes to be used to fill any cells within the intersection of the source rectangle and
             clipping rectangle that are left "empty" by the move.
            
             </param>
        <summary>
            
             Scroll a region of the screen buffer.
            
             </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Int32,System.Int32,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Management.Automation.Host.Size,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.String[],System.ConsoleColor,System.ConsoleColor)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.Char)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.GetBufferContents(System.Management.Automation.Host.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="SetBufferContents">
      <MemberSignature Language="C#" Value="public abstract void SetBufferContents (System.Management.Automation.Host.Coordinates origin, System.Management.Automation.Host.BufferCell[,] contents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetBufferContents(valuetype System.Management.Automation.Host.Coordinates origin, valuetype System.Management.Automation.Host.BufferCell[,] contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetBufferContents (origin As Coordinates, contents As BufferCell(,))" />
      <MemberSignature Language="F#" Value="abstract member SetBufferContents : System.Management.Automation.Host.Coordinates * System.Management.Automation.Host.BufferCell[,] -&gt; unit" Usage="pSHostRawUserInterface.SetBufferContents (origin, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="origin" Type="System.Management.Automation.Host.Coordinates" />
        <Parameter Name="contents" Type="System.Management.Automation.Host.BufferCell[,]" />
      </Parameters>
      <Docs>
        <param name="origin">
            
             The top left corner of the rectangular screen area to which <paramref name="contents" /> is copied.
            
             </param>
        <param name="contents">
            
             A rectangle of <see cref="T:System.Management.Automation.Host.BufferCell" /> objects to be copied to the
             screen buffer.
            
             </param>
        <summary>
            
             Copies the <see cref="T:System.Management.Automation.Host.BufferCell" /> array into the screen buffer at the
             given origin, clipping such that cells in the array that would fall outside the screen buffer are ignored.
            
             </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Int32,System.Int32,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Management.Automation.Host.Size,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.String[],System.ConsoleColor,System.ConsoleColor)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.Char)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.GetBufferContents(System.Management.Automation.Host.Rectangle)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ScrollBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
      </Docs>
    </Member>
    <Member MemberName="SetBufferContents">
      <MemberSignature Language="C#" Value="public abstract void SetBufferContents (System.Management.Automation.Host.Rectangle rectangle, System.Management.Automation.Host.BufferCell fill);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetBufferContents(valuetype System.Management.Automation.Host.Rectangle rectangle, valuetype System.Management.Automation.Host.BufferCell fill) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
      <MemberSignature Language="F#" Value="abstract member SetBufferContents : System.Management.Automation.Host.Rectangle * System.Management.Automation.Host.BufferCell -&gt; unit" Usage="pSHostRawUserInterface.SetBufferContents (rectangle, fill)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rectangle" Type="System.Management.Automation.Host.Rectangle" />
        <Parameter Name="fill" Type="System.Management.Automation.Host.BufferCell" />
      </Parameters>
      <Docs>
        <param name="rectangle">
            
             The rectangle on the screen buffer to which <paramref name="fill" /> is copied.
             If all elements are -1, the entire screen buffer will be copied with <paramref name="fill" />.
            
             </param>
        <param name="fill">
            
             The character and attributes used to fill <paramref name="rectangle" />.
            
             </param>
        <summary>
            
             Copies a given character to all of the character cells in the screen buffer with the indicated colors.
            
             </summary>
        <remarks>
            
             Provided for clearing regions -- less chatty than passing an array of cells.
            
             </remarks>
        <example>
          <snippet Code="C#">
                     using System;
                     using System.Management.Automation;
                     using System.Management.Automation.Host;
                     namespace Microsoft.Samples.MSH.Cmdlet
                     {
                         [Cmdlet("Clear","Screen")]
                         public class ClearScreen : PSCmdlet
                         {
                             protected override void BeginProcessing()
                             {
                                 Host.UI.RawUI.SetBufferContents(new Rectangle(-1, -1, -1, -1),
                                     new BufferCell(' ', Host.UI.RawUI.ForegroundColor, Host.UI.RawUI.BackgroundColor))
                             }
                         }
                     }
                 </snippet>
        </example>
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Int32,System.Int32,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.Management.Automation.Host.Size,System.Management.Automation.Host.BufferCell)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.NewBufferCellArray(System.String[],System.ConsoleColor,System.ConsoleColor)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.Char)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.LengthInBufferCells(System.String)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.SetBufferContents(System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.BufferCell[0:,0:])" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.GetBufferContents(System.Management.Automation.Host.Rectangle)" />
        <altmember cref="M:System.Management.Automation.Host.PSHostRawUserInterface.ScrollBufferContents(System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.Coordinates,System.Management.Automation.Host.Rectangle,System.Management.Automation.Host.BufferCell)" />
      </Docs>
    </Member>
    <Member MemberName="WindowPosition">
      <MemberSignature Language="C#" Value="public abstract System.Management.Automation.Host.Coordinates WindowPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.Host.Coordinates WindowPosition" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowPosition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property WindowPosition As Coordinates" />
      <MemberSignature Language="F#" Value="member this.WindowPosition : System.Management.Automation.Host.Coordinates with get, set" Usage="System.Management.Automation.Host.PSHostRawUserInterface.WindowPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.Coordinates</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            
             Gets or sets position of the view window relative to the screen buffer, in characters. (0,0) is the upper left of the screen
             buffer.
            
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxPhysicalWindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.CursorPosition" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxWindowSize" />
      </Docs>
    </Member>
    <Member MemberName="WindowSize">
      <MemberSignature Language="C#" Value="public abstract System.Management.Automation.Host.Size WindowSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.Host.Size WindowSize" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowSize" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property WindowSize As Size" />
      <MemberSignature Language="F#" Value="member this.WindowSize : System.Management.Automation.Host.Size with get, set" Usage="System.Management.Automation.Host.PSHostRawUserInterface.WindowSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Host.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            
             Gets or sets the current view window size, measured in character cells.  The window size cannot be larger than the
             dimensions returned by <see cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxPhysicalWindowSize" />.
            
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxPhysicalWindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.BufferSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.CursorPosition" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.MaxWindowSize" />
        <altmember cref="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowPosition" />
      </Docs>
    </Member>
    <Member MemberName="WindowTitle">
      <MemberSignature Language="C#" Value="public abstract string WindowTitle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Management.Automation.Host.PSHostRawUserInterface.WindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property WindowTitle As String" />
      <MemberSignature Language="F#" Value="member this.WindowTitle : string with get, set" Usage="System.Management.Automation.Host.PSHostRawUserInterface.WindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            
             Gets or sets the titlebar text of the current view window.
            
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>