<Type Name="ReceivePSSessionCommand" FullName="Microsoft.PowerShell.Commands.ReceivePSSessionCommand">
  <TypeSignature Language="C#" Value="public class ReceivePSSessionCommand : Microsoft.PowerShell.Commands.PSRemotingCmdlet" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReceivePSSessionCommand extends Microsoft.PowerShell.Commands.PSRemotingCmdlet" />
  <TypeSignature Language="DocId" Value="T:Microsoft.PowerShell.Commands.ReceivePSSessionCommand" />
  <TypeSignature Language="VB.NET" Value="Public Class ReceivePSSessionCommand&#xA;Inherits PSRemotingCmdlet" />
  <TypeSignature Language="F#" Value="type ReceivePSSessionCommand = class&#xA;    inherit PSRemotingCmdlet" />
  <AssemblyInfo>
    <AssemblyName>System.Management.Automation</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.PowerShell.Commands.PSRemotingCmdlet</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Management.Automation.Cmdlet("Receive", "PSSession", DefaultParameterSetName="Session", HelpUri="https://go.microsoft.com/fwlink/?LinkID=217037", RemotingCapability=System.Management.Automation.RemotingCapability.OwnedByCommand, SupportsShouldProcess=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
             This cmdlet connects a running command associated with a PS session and then
             directs the command output either:
             a) To Host.  This is the synchronous mode of the cmdlet which won't return
                until the running command completes and all output data is received on
                the client.
             b) To a job object.  This is the asynchronous mode of the cmdlet which will
                return immediately providing the job object that is collecting the
                running command output data.
            
             The running command becomes disconnected when the associated runspace is
             disconnected (via the Disconnect-PSSession cmdlet).
            
             The associated runspace object must be in the Opened state (connected) before
             the running command can be connected.  If the associated runspace object is
             in the disconnected state, it will first be connected before the running
             command is connected.
            
             The user can specify how command output data is returned by using the public
             OutTarget enumeration (Host, Job).
             The default actions of this cmdlet is to always direct ouput to host unless
             a job object already exists on the client that is associated with the running
             command.  In this case the existing job object is connected to the running
             command and returned.
            
             The cmdlet can be used in the following ways:
            
             Receive PS session data by session object
             &gt; $session = New-PSSession serverName
             &gt; $job1 = Invoke-Command $session { [script] } -asjob
             &gt; Disconnect-PSSession $session
             &gt; Connect-PSSession $session
             &gt; Receive-PSSession $session    // command output continues collecting at job object.
            
             Receive PS session data by session Id
             &gt; Receive-PSSession $session.Id
            
             Receive PS session data by session instance Id
             &gt; Receive-PSSession $session.InstanceId
            
             Receive PS session data by session Name.  Direct output to job
             &gt; Receive-PSSession $session.Name
            
             Receive a running command from a computer.
             &gt; $job = Receive-PSSession -ComputerName ServerOne -Name SessionName -OutTarget Job
            
             </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReceivePSSessionCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowRedirection">
      <MemberSignature Language="C#" Value="public System.Management.Automation.SwitchParameter AllowRedirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.SwitchParameter AllowRedirection" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.AllowRedirection" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowRedirection As SwitchParameter" />
      <MemberSignature Language="F#" Value="member this.AllowRedirection : System.Management.Automation.SwitchParameter with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.AllowRedirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Management.Automation.SwitchParameter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The AllowRedirection parameter enables the implicit redirection functionality.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerSessionName", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            This parameters specifies the appname which identifies the connection
            end point on the remote machine. If this parameter is not specified
            then the value specified in DEFAULTREMOTEAPPNAME will be used. If thats
            not specified as well, then "WSMAN" will be used
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Authentication">
      <MemberSignature Language="C#" Value="public System.Management.Automation.Runspaces.AuthenticationMechanism Authentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.Runspaces.AuthenticationMechanism Authentication" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Authentication" />
      <MemberSignature Language="VB.NET" Value="Public Property Authentication As AuthenticationMechanism" />
      <MemberSignature Language="F#" Value="member this.Authentication : System.Management.Automation.Runspaces.AuthenticationMechanism with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Authentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Runspaces.AuthenticationMechanism</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Use basic authentication to authenticate the user.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CertificateThumbprint">
      <MemberSignature Language="C#" Value="public string CertificateThumbprint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CertificateThumbprint" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.CertificateThumbprint" />
      <MemberSignature Language="VB.NET" Value="Public Property CertificateThumbprint As String" />
      <MemberSignature Language="F#" Value="member this.CertificateThumbprint : string with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.CertificateThumbprint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Specifies the certificate thumbprint to be used to impersonate the user on the
            remote machine.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ComputerName">
      <MemberSignature Language="C#" Value="public string ComputerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ComputerName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.ComputerName" />
      <MemberSignature Language="VB.NET" Value="Public Property ComputerName As String" />
      <MemberSignature Language="F#" Value="member this.ComputerName : string with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.ComputerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Alias(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ComputerSessionName", Position=0, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ComputerInstanceId", Position=0, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateNotNullOrEmpty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Computer name to receive session data from.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerSessionName", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriSessionName", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            If this parameter is not specified then the value specified in
            the environment variable DEFAULTREMOTESHELLNAME will be used. If
            this is not set as well, then Microsoft.PowerShell is used.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectionUri">
      <MemberSignature Language="C#" Value="public Uri ConnectionUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri ConnectionUri" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.ConnectionUri" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectionUri As Uri" />
      <MemberSignature Language="F#" Value="member this.ConnectionUri : Uri with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.ConnectionUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Alias(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ConnectionUriSessionName", Position=0, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ConnectionUriInstanceId", Position=0, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateNotNullOrEmpty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            A complete URI(s) specified for the remote computer and shell to
            connect to and create a runspace for.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Credential">
      <MemberSignature Language="C#" Value="public System.Management.Automation.PSCredential Credential { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Management.Automation.PSCredential Credential" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Credential" />
      <MemberSignature Language="VB.NET" Value="Public Property Credential As PSCredential" />
      <MemberSignature Language="F#" Value="member this.Credential : System.Management.Automation.PSCredential with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Credential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Credential</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Management.Automation.PSCredential</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Specifies the credentials of the user to impersonate in the
            remote machine. If this parameter is not specified then the
            credentials of the current user process will be assumed.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Id" />
      <MemberSignature Language="VB.NET" Value="Public Property Id As Integer" />
      <MemberSignature Language="F#" Value="member this.Id : int with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="Id", Position=0, ValueFromPipeline=true, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Session Id of PSSession object to receive data from.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceId">
      <MemberSignature Language="C#" Value="public Guid InstanceId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid InstanceId" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.InstanceId" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceId As Guid" />
      <MemberSignature Language="F#" Value="member this.InstanceId : Guid with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.InstanceId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="InstanceId", Position=0, ValueFromPipeline=true, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateNotNullOrEmpty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Instance Id of PSSession object to receive data from.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="JobName">
      <MemberSignature Language="C#" Value="public string JobName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string JobName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.JobName" />
      <MemberSignature Language="VB.NET" Value="Public Property JobName As String" />
      <MemberSignature Language="F#" Value="member this.JobName : string with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.JobName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="Session")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="Id")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="InstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="SessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateNotNullOrEmpty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Provides job name when job is created for returned data.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="SessionName", Position=0, ValueFromPipeline=true, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ComputerSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ConnectionUriSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateNotNullOrEmpty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Name of PSSession object to receive data from.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OutTarget">
      <MemberSignature Language="C#" Value="public Microsoft.PowerShell.Commands.OutTarget OutTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.PowerShell.Commands.OutTarget OutTarget" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.OutTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property OutTarget As OutTarget" />
      <MemberSignature Language="F#" Value="member this.OutTarget : Microsoft.PowerShell.Commands.OutTarget with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.OutTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="Session")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="Id")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="InstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="SessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.PowerShell.Commands.OutTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Determines how running command output is returned on client.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Port" />
      <MemberSignature Language="VB.NET" Value="Public Property Port As Integer" />
      <MemberSignature Language="F#" Value="member this.Port : int with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateRange(Mono.Cecil.CustomAttributeArgument, Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Port specifies the alternate port to be used in case the
            default ports are not used for the transport mechanism
            (port 80 for http and port 443 for useSSL)
            </summary>
        <value>To be added.</value>
        <remarks>
            Currently this is being accepted as a parameter. But in future
            support will be added to make this a part of a policy setting.
            When a policy setting is in place this parameter can be used
            to override the policy setting
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessRecord">
      <MemberSignature Language="C#" Value="protected override void ProcessRecord ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ProcessRecord() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.ProcessRecord" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ProcessRecord ()" />
      <MemberSignature Language="F#" Value="override this.ProcessRecord : unit -&gt; unit" Usage="receivePSSessionCommand.ProcessRecord " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Process input.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Management.Automation.Runspaces.PSSession Session { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Management.Automation.Runspaces.PSSession Session" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Session" />
      <MemberSignature Language="VB.NET" Value="Public Property Session As PSSession" />
      <MemberSignature Language="F#" Value="member this.Session : System.Management.Automation.Runspaces.PSSession with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="Session", Position=0, ValueFromPipeline=true, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateNotNullOrEmpty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Runspaces.PSSession</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The PSSession object to receive data from.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionOption">
      <MemberSignature Language="C#" Value="public System.Management.Automation.Remoting.PSSessionOption SessionOption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Management.Automation.Remoting.PSSessionOption SessionOption" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.SessionOption" />
      <MemberSignature Language="VB.NET" Value="Public Property SessionOption As PSSessionOption" />
      <MemberSignature Language="F#" Value="member this.SessionOption : System.Management.Automation.Remoting.PSSessionOption with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.SessionOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriSessionName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Remoting.PSSessionOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Session options.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopProcessing">
      <MemberSignature Language="C#" Value="protected override void StopProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void StopProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.StopProcessing" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub StopProcessing ()" />
      <MemberSignature Language="F#" Value="override this.StopProcessing : unit -&gt; unit" Usage="receivePSSessionCommand.StopProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            User has signaled a stop for this cmdlet.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseSSL">
      <MemberSignature Language="C#" Value="public System.Management.Automation.SwitchParameter UseSSL { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.SwitchParameter UseSSL" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.ReceivePSSessionCommand.UseSSL" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSSL As SwitchParameter" />
      <MemberSignature Language="F#" Value="member this.UseSSL : System.Management.Automation.SwitchParameter with get, set" Usage="Microsoft.PowerShell.Commands.ReceivePSSessionCommand.UseSSL" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerSessionName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Management.Automation.SwitchParameter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            This parameter suggests that the transport scheme to be used for
            remote connections is useSSL instead of the default http.Since
            there are only two possible transport schemes that are possible
            at this point, a SwitchParameter is being used to switch between
            the two.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>