<Type Name="GetPSSessionCommand" FullName="Microsoft.PowerShell.Commands.GetPSSessionCommand">
  <TypeSignature Language="C#" Value="public class GetPSSessionCommand : Microsoft.PowerShell.Commands.PSRunspaceCmdlet, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GetPSSessionCommand extends Microsoft.PowerShell.Commands.PSRunspaceCmdlet implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.PowerShell.Commands.GetPSSessionCommand" />
  <TypeSignature Language="VB.NET" Value="Public Class GetPSSessionCommand&#xA;Inherits PSRunspaceCmdlet&#xA;Implements IDisposable" />
  <TypeSignature Language="F#" Value="type GetPSSessionCommand = class&#xA;    inherit PSRunspaceCmdlet&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Management.Automation</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Microsoft.PowerShell.Commands.PSRunspaceCmdlet</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Management.Automation.Cmdlet("Get", "PSSession", DefaultParameterSetName="Name", HelpUri="https://go.microsoft.com/fwlink/?LinkID=135219", RemotingCapability=System.Management.Automation.RemotingCapability.OwnedByCommand)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Management.Automation.OutputType(typeof(System.Management.Automation.Runspaces.PSSession))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
             This cmdlet is used to retrieve runspaces from the global cache
             and write it to the pipeline. The runspaces are wrapped and
             returned as PSSession objects.
            
             The cmdlet can be used in the following ways:
            
             List all the available runspaces
                 get-pssession
            
             Get the PSSession from session name
                 get-pssession -Name sessionName
            
             Get the PSSession for the specified ID
                 get-pssession -Id sessionId
            
             Get the PSSession for the specified instance Guid
                 get-pssession -InstanceId sessionGuid
            
             Get PSSessions from remote computer.  Optionally filter on state, session instanceid or session name.
                 get-psession -ComputerName computerName -StateFilter Disconnected
            
             Get PSSessions from virtual machine. Optionally filter on state, session instanceid or session name.
                 get-psession -VMName vmName -Name sessionName
            
             Get PSSessions from container. Optionally filter on state, session instanceid or session name.
                 get-psession -ContainerId containerId -InstanceId instanceId
            
             </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GetPSSessionCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.PowerShell.Commands.GetPSSessionCommand.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowRedirection">
      <MemberSignature Language="C#" Value="public System.Management.Automation.SwitchParameter AllowRedirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.SwitchParameter AllowRedirection" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.AllowRedirection" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowRedirection As SwitchParameter" />
      <MemberSignature Language="F#" Value="member this.AllowRedirection : System.Management.Automation.SwitchParameter with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.AllowRedirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUri")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Management.Automation.SwitchParameter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The AllowRedirection parameter enables the implicit redirection functionality.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerName", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            This parameters specifies the appname which identifies the connection
            end point on the remote machine. If this parameter is not specified
            then the value specified in DEFAULTREMOTEAPPNAME will be used. If thats
            not specified as well, then "WSMAN" will be used
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Authentication">
      <MemberSignature Language="C#" Value="public System.Management.Automation.Runspaces.AuthenticationMechanism Authentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.Runspaces.AuthenticationMechanism Authentication" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.Authentication" />
      <MemberSignature Language="VB.NET" Value="Public Property Authentication As AuthenticationMechanism" />
      <MemberSignature Language="F#" Value="member this.Authentication : System.Management.Automation.Runspaces.AuthenticationMechanism with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.Authentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUri")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Runspaces.AuthenticationMechanism</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Use basic authentication to authenticate the user.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginProcessing">
      <MemberSignature Language="C#" Value="protected override void BeginProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void BeginProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.PowerShell.Commands.GetPSSessionCommand.BeginProcessing" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub BeginProcessing ()" />
      <MemberSignature Language="F#" Value="override this.BeginProcessing : unit -&gt; unit" Usage="getPSSessionCommand.BeginProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Resolves shellname
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CertificateThumbprint">
      <MemberSignature Language="C#" Value="public string CertificateThumbprint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CertificateThumbprint" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.CertificateThumbprint" />
      <MemberSignature Language="VB.NET" Value="Public Property CertificateThumbprint As String" />
      <MemberSignature Language="F#" Value="member this.CertificateThumbprint : string with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.CertificateThumbprint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUri")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Specifies the certificate thumbprint to be used to impersonate the user on the
            remote machine.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ComputerName">
      <MemberSignature Language="C#" Value="public override string[] ComputerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] ComputerName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.ComputerName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ComputerName As String()" />
      <MemberSignature Language="F#" Value="member this.ComputerName : string[] with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.ComputerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Alias(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ComputerName", Position=0, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ComputerInstanceId", Position=0, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateNotNullOrEmpty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Computer names to connect to.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerName", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUri", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ContainerId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ContainerIdInstanceId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="VMId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="VMIdInstanceId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="VMName", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="VMNameInstanceId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             For WSMan sessions:
             If this parameter is not specified then the value specified in
             the environment variable DEFAULTREMOTESHELLNAME will be used. If
             this is not set as well, then Microsoft.PowerShell is used.
            
             For VM/Container sessions:
             If this parameter is not specified then all sessions that match other filters are returned.
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectionUri">
      <MemberSignature Language="C#" Value="public Uri[] ConnectionUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri[] ConnectionUri" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.ConnectionUri" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectionUri As Uri()" />
      <MemberSignature Language="F#" Value="member this.ConnectionUri : Uri[] with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.ConnectionUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Alias(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ConnectionUri", Position=0, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ConnectionUriInstanceId", Position=0, ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateNotNullOrEmpty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            A complete URI(s) specified for the remote computer and shell to
            connect to and create a runspace for.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Credential">
      <MemberSignature Language="C#" Value="public System.Management.Automation.PSCredential Credential { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Management.Automation.PSCredential Credential" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.Credential" />
      <MemberSignature Language="VB.NET" Value="Public Property Credential As PSCredential" />
      <MemberSignature Language="F#" Value="member this.Credential : System.Management.Automation.PSCredential with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.Credential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Credential</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUri")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Management.Automation.PSCredential</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Specifies the credentials of the user to impersonate in the
            remote machine. If this parameter is not specified then the
            credentials of the current user process will be assumed.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.PowerShell.Commands.GetPSSessionCommand.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="getPSSessionCommand.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Dispose method of IDisposable.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndProcessing">
      <MemberSignature Language="C#" Value="protected override void EndProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void EndProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.PowerShell.Commands.GetPSSessionCommand.EndProcessing" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub EndProcessing ()" />
      <MemberSignature Language="F#" Value="override this.EndProcessing : unit -&gt; unit" Usage="getPSSessionCommand.EndProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            End processing clean up.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceId">
      <MemberSignature Language="C#" Value="public override Guid[] InstanceId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid[] InstanceId" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.InstanceId" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InstanceId As Guid()" />
      <MemberSignature Language="F#" Value="member this.InstanceId : Guid[] with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.InstanceId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="InstanceId", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="ContainerIdInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="VMIdInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(Mandatory=true, ParameterSetName="VMNameInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateNotNull</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Instance Ids to filter on.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string[] Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Name As String()" />
      <MemberSignature Language="F#" Value="member this.Name : string[] with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUri")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="Name", ValueFromPipelineByPropertyName=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ContainerId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="VMId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="VMName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateNotNullOrEmpty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Session names to filter on.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.Port" />
      <MemberSignature Language="VB.NET" Value="Public Property Port As Integer" />
      <MemberSignature Language="F#" Value="member this.Port : int with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.ValidateRange(Mono.Cecil.CustomAttributeArgument, Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Port specifies the alternate port to be used in case the
            default ports are not used for the transport mechanism
            (port 80 for http and port 443 for useSSL)
            </summary>
        <value>To be added.</value>
        <remarks>
            Currently this is being accepted as a parameter. But in future
            support will be added to make this a part of a policy setting.
            When a policy setting is in place this parameter can be used
            to override the policy setting
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessRecord">
      <MemberSignature Language="C#" Value="protected override void ProcessRecord ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ProcessRecord() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.PowerShell.Commands.GetPSSessionCommand.ProcessRecord" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ProcessRecord ()" />
      <MemberSignature Language="F#" Value="override this.ProcessRecord : unit -&gt; unit" Usage="getPSSessionCommand.ProcessRecord " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Get the list of runspaces from the global cache and write them
            down. If no computername or instance id is specified then
            list all runspaces
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionOption">
      <MemberSignature Language="C#" Value="public System.Management.Automation.Remoting.PSSessionOption SessionOption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Management.Automation.Remoting.PSSessionOption SessionOption" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.SessionOption" />
      <MemberSignature Language="VB.NET" Value="Public Property SessionOption As PSSessionOption" />
      <MemberSignature Language="F#" Value="member this.SessionOption : System.Management.Automation.Remoting.PSSessionOption with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.SessionOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUri")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Management.Automation.Remoting.PSSessionOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Session options.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public Microsoft.PowerShell.Commands.SessionFilterState State { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.PowerShell.Commands.SessionFilterState State" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.State" />
      <MemberSignature Language="VB.NET" Value="Public Property State As SessionFilterState" />
      <MemberSignature Language="F#" Value="member this.State : Microsoft.PowerShell.Commands.SessionFilterState with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.State" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUri")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ContainerId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ContainerIdInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="VMId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="VMIdInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="VMName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="VMNameInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.PowerShell.Commands.SessionFilterState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Filters returned remote runspaces based on runspace state.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopProcessing">
      <MemberSignature Language="C#" Value="protected override void StopProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void StopProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.PowerShell.Commands.GetPSSessionCommand.StopProcessing" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub StopProcessing ()" />
      <MemberSignature Language="F#" Value="override this.StopProcessing : unit -&gt; unit" Usage="getPSSessionCommand.StopProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            User has signaled a stop for this cmdlet.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrottleLimit">
      <MemberSignature Language="C#" Value="public int ThrottleLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ThrottleLimit" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.ThrottleLimit" />
      <MemberSignature Language="VB.NET" Value="Public Property ThrottleLimit As Integer" />
      <MemberSignature Language="F#" Value="member this.ThrottleLimit : int with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.ThrottleLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUri")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ConnectionUriInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Allows the user of the cmdlet to specify a throttling value
            for throttling the number of remote operations that can
            be executed simultaneously.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseSSL">
      <MemberSignature Language="C#" Value="public System.Management.Automation.SwitchParameter UseSSL { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Management.Automation.SwitchParameter UseSSL" />
      <MemberSignature Language="DocId" Value="P:Microsoft.PowerShell.Commands.GetPSSessionCommand.UseSSL" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSSL As SwitchParameter" />
      <MemberSignature Language="F#" Value="member this.UseSSL : System.Management.Automation.SwitchParameter with get, set" Usage="Microsoft.PowerShell.Commands.GetPSSessionCommand.UseSSL" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management.Automation</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Management.Automation.Parameter(ParameterSetName="ComputerInstanceId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Management.Automation.SwitchParameter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            This parameter suggests that the transport scheme to be used for
            remote connections is useSSL instead of the default http.Since
            there are only two possible transport schemes that are possible
            at this point, a SwitchParameter is being used to switch between
            the two.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>